/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails oncall+recoil
 * @flow strict-local
 * @format
 */
'use strict';

const {
  getRecoilTestFn
} = require('recoil-shared/__test_utils__/Recoil_TestingUtils');

let React, act, useTransition, useRecoilState, atom, renderElements, reactMode, flushPromisesAndTimers;
const testRecoil = getRecoilTestFn(() => {
  React = require('react');
  ({
    useTransition
  } = React);
  ({
    act
  } = require('ReactTestUtils'));
  ({
    useRecoilState,
    atom
  } = require('../../Recoil_index'));
  ({
    renderElements,
    flushPromisesAndTimers
  } = require('recoil-shared/__test_utils__/Recoil_TestingUtils'));
  ({
    reactMode
  } = require('../../core/Recoil_ReactMode'));
});
let nextID = 0;
testRecoil('Works with useTransition', async ({
  concurrentMode
}) => {
  if (!reactMode().concurrent || !concurrentMode) {
    return;
  }

  const indexAtom = atom({
    key: `index${nextID++}`,
    default: 0
  }); // Basic implementation of a cache that suspends:

  const cache = new Map();
  const resolvers = [];
  declare function getItem(index: any): any;
  declare function ItemContents(arg0: any): any;
  declare function Item(arg0: any): any;
  let incrementIndex;
  declare function Main(): any;
  const c = renderElements(<Main />); // Initial load:

  expect(c.textContent).toEqual('Index: 0 - Suspended');
  act(() => resolvers[0]());
  await flushPromisesAndTimers();
  expect(c.textContent).toEqual('Index: 0 - Item 0 = v0'); // Increment index a single time; see previous item in transition, then once
  // the new item resolves, see the new item:

  act(() => incrementIndex());
  expect(c.textContent).toEqual('Index: 0 - In transition - Item 0 = v0');
  act(() => resolvers[1]());
  await flushPromisesAndTimers();
  expect(c.textContent).toEqual('Index: 1 - Item 1 = v1'); // Increment index a second time during transition; see previous item in
  // transition, then once the new _second_ item resolves, see that new item:

  act(() => incrementIndex());
  expect(c.textContent).toEqual('Index: 1 - In transition - Item 1 = v1');
  act(() => incrementIndex());
  expect(c.textContent).toEqual('Index: 1 - In transition - Item 1 = v1');
  act(() => resolvers[2]());
  await flushPromisesAndTimers();
  expect(c.textContent).toEqual('Index: 1 - In transition - Item 1 = v1');
  act(() => resolvers[3]());
  await flushPromisesAndTimers();
  expect(c.textContent).toEqual('Index: 3 - Item 3 = v3');
});