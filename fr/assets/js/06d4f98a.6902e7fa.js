(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{149:function(e,n,r){"use strict";r.d(n,"a",(function(){return d})),r.d(n,"b",(function(){return f}));var t=r(0),s=r.n(t);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function u(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?u(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):u(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function i(e,n){if(null==e)return{};var r,t,s=function(e,n){if(null==e)return{};var r,t,s={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(s[r]=e[r]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var c=s.a.createContext({}),l=function(e){var n=s.a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},d=function(e){var n=l(e.components);return s.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return s.a.createElement(s.a.Fragment,{},n)}},m=s.a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,a=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=l(r),m=t,f=d["".concat(u,".").concat(m)]||d[m]||p[m]||a;return r?s.a.createElement(f,o(o({ref:n},c),{},{components:r})):s.a.createElement(f,o({ref:n},c))}));function f(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=r.length,u=new Array(a);u[0]=m;var o={};for(var i in n)hasOwnProperty.call(n,i)&&(o[i]=n[i]);o.originalType=e,o.mdxType="string"==typeof e?e:t,u[1]=o;for(var c=2;c<a;c++)u[c]=r[c];return s.a.createElement.apply(null,u)}return s.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},72:function(e,n,r){"use strict";r.r(n),r.d(n,"frontMatter",(function(){return u})),r.d(n,"metadata",(function(){return o})),r.d(n,"toc",(function(){return i})),r.d(n,"default",(function(){return l}));var t=r(3),s=r(8),a=(r(0),r(149)),u={title:"Requ\xeates de donn\xe9es asynchrones",sidebar_label:"Requ\xeates asynchrones"},o={unversionedId:"guides/asynchronous-data-queries",id:"guides/asynchronous-data-queries",isDocsHomePage:!1,title:"Requ\xeates de donn\xe9es asynchrones",description:"Recoil fournit un moyen de mapper \xe9tat et \xe9tat d\xe9riv\xe9 aux composants React via un graphe de flux de donn\xe9es. Ce qui est vraiment puissant, c'est que les fonctions du graphe peuvent \xe9galement \xeatre asynchrones. Cela facilite l'utilisation de fonctions asynchrones au sein de fonctions synchrones de composants React. Recoil vous permet de m\xe9langer de mani\xe8re transparente des fonctions synchrones et asynchrones dans votre graphe de flux de donn\xe9es de s\xe9lecteurs. Renvoyez simplement une promesse de valeur au lieu de la valeur elle-m\xeame \xe0 partir d'un rappel de s\xe9lecteur get, l'interface reste exactement la m\xeame. Comme ce ne sont que des s\xe9lecteurs, d'autres s\xe9lecteurs peuvent \xe9galement en d\xe9pendre pour transformer davantage les donn\xe9es.",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/guides/asynchronous-data-queries.md",slug:"/guides/asynchronous-data-queries",permalink:"/fr/docs/guides/asynchronous-data-queries",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/i18n/fr/docusaurus-plugin-content-docs/current/guides/asynchronous-data-queries.md",version:"current",sidebar_label:"Requ\xeates asynchrones",sidebar:"docs",previous:{title:"S\xe9lecteurs",permalink:"/fr/docs/basic-tutorial/selectors"},next:{title:"Effets Atomiques",permalink:"/fr/docs/guides/atom-effects"}},i=[{value:"Exemple synchrone",id:"exemple-synchrone",children:[]},{value:"Exemple asynchrone",id:"exemple-asynchrone",children:[]},{value:"La gestion d&#39;erreurs",id:"la-gestion-derreurs",children:[]},{value:"Requ\xeates avec param\xe8tres",id:"requ\xeates-avec-param\xe8tres",children:[]},{value:"Graphe de flux de donn\xe9es",id:"graphe-de-flux-de-donn\xe9es",children:[]},{value:"Requ\xeates concomitantes",id:"requ\xeates-concomitantes",children:[]},{value:"Pr\xe9lecture",id:"pr\xe9lecture",children:[]},{value:"Requ\xeater les valeurs par d\xe9faut de atomes",id:"requ\xeater-les-valeurs-par-d\xe9faut-de-atomes",children:[]},{value:"Requ\xeates asynchrones sans React Suspense",id:"requ\xeates-asynchrones-sans-react-suspense",children:[]},{value:"Actualisation de requ\xeate",id:"actualisation-de-requ\xeate",children:[{value:"Utiliser des requ\xeates identifiable",id:"utiliser-des-requ\xeates-identifiable",children:[]},{value:"Utiliser un atome",id:"utiliser-un-atome",children:[]}]}],c={toc:i};function l(e){var n=e.components,r=Object(s.a)(e,["components"]);return Object(a.b)("wrapper",Object(t.a)({},c,r,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Recoil fournit un moyen de mapper \xe9tat et \xe9tat d\xe9riv\xe9 aux composants React via un graphe de flux de donn\xe9es. Ce qui est vraiment puissant, c'est que les fonctions du graphe peuvent \xe9galement \xeatre asynchrones. Cela facilite l'utilisation de fonctions asynchrones au sein de fonctions synchrones de composants React. Recoil vous permet de m\xe9langer de mani\xe8re transparente des fonctions synchrones et asynchrones dans votre graphe de flux de donn\xe9es de s\xe9lecteurs. Renvoyez simplement une promesse de valeur au lieu de la valeur elle-m\xeame \xe0 partir d'un rappel de s\xe9lecteur ",Object(a.b)("inlineCode",{parentName:"p"},"get"),", l'interface reste exactement la m\xeame. Comme ce ne sont que des s\xe9lecteurs, d'autres s\xe9lecteurs peuvent \xe9galement en d\xe9pendre pour transformer davantage les donn\xe9es."),Object(a.b)("p",null,"Les s\xe9lecteurs peuvent \xeatre utilis\xe9s comme un moyen d'incorporer des donn\xe9es asynchrones dans le graphe de flux de donn\xe9es Recoil. Veuillez garder \xe0 l'esprit que les s\xe9lecteurs repr\xe9sentent des fonctions \"idempotentes\": pour un ensemble donn\xe9 d'entr\xe9es, ils doivent toujours produire les m\xeames r\xe9sultats (au moins pour la dur\xe9e de vie de l'application). Ceci est important car les r\xe9sultats de l'\xe9valuations de ces s\xe9lecteurs peuvent \xeatre mises en cache, red\xe9marr\xe9es ou ex\xe9cut\xe9es plusieurs fois. Pour cette raison, les s\xe9lecteurs sont g\xe9n\xe9ralement un bon moyen de mod\xe9liser des requ\xeates de base de donn\xe9es en lecture seule. Pour les donn\xe9es mutables, vous pouvez utiliser une ",Object(a.b)("a",{parentName:"p",href:"#query-refresh"},"Query Refresh")," (Actualisation de requ\xeate) ou pour synchroniser un \xe9tat mutable, un \xe9tat persistant ou pour d'autres effets secondaires, pensez \xe0 l'API exp\xe9rimentale pour ",Object(a.b)("a",{parentName:"p",href:"/docs/guides/atom-effects"},"Effets Atomiques"),"."),Object(a.b)("h2",{id:"exemple-synchrone"},"Exemple synchrone"),Object(a.b)("p",null,"Par exemple, voici un simple synchrone ",Object(a.b)("a",{parentName:"p",href:"/docs/api-reference/core/atom"},"atome")," et ",Object(a.b)("a",{parentName:"p",href:"/docs/api-reference/core/selector"},"s\xe9lecteur")," pour obtenir un nom d'utilisateur:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const currentUserIDState = atom({\n  key: 'CurrentUserID',\n  default: 1,\n});\n\nconst currentUserNameState = selector({\n  key: 'CurrentUserName',\n  get: ({get}) => {\n    return tableOfUsers[get(currentUserIDState)].name;\n  },\n});\n\nfunction CurrentUserInfo() {\n  const userName = useRecoilValue(currentUserNameState);\n  return <div>{userName}</div>;\n}\n\nfunction MonApplication() {\n  return (\n    <RecoilRoot>\n      <CurrentUserInfo />\n    </RecoilRoot>\n  );\n}\n")),Object(a.b)("h2",{id:"exemple-asynchrone"},"Exemple asynchrone"),Object(a.b)("p",null,"Si les noms d'utilisateur ont \xe9t\xe9 stock\xe9s dans une base de donn\xe9es que nous devons interroger, tout ce que nous devons faire est de retourner une ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," ou d'utiliser une fonction",Object(a.b)("inlineCode",{parentName:"p"}," async"),". Si des d\xe9pendances changent, le s\xe9lecteur sera r\xe9\xe9valu\xe9 et ex\xe9cutera une nouvelle requ\xeate. Les r\xe9sultats sont mis en cache, de sorte que la requ\xeate ne s'ex\xe9cutera qu'une seule fois par entr\xe9e unique."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const currentUserNameQuery = selector({\n  key: 'CurrentUserName',\n  get: async ({get}) => {\n    const response = await myDBQuery({\n      userID: get(currentUserIDState),\n    });\n    return response.name;\n  },\n});\n\nfunction CurrentUserInfo() {\n  const userName = useRecoilValue(currentUserNameQuery);\n  return <div>{userName}</div>;\n}\n")),Object(a.b)("p",null,"L'interface du s\xe9lecteur est la m\xeame, donc le composant utilisant ce s\xe9lecteur n'a pas besoin de se soucier si la value provient d'un \xe9tat d'atome synchrone, d'un \xe9tat de s\xe9lecteur d\xe9riv\xe9 ou de requ\xeates asynchrones!"),Object(a.b)("p",null,"Mais, puisque les fonctions de rendu de React sont synchrones, que rendront-t-elles avant la r\xe9solution de la promesse? Recoil est con\xe7u pour fonctionner avec ",Object(a.b)("a",{parentName:"p",href:"https://reactjs.org/docs/concurrent-mode-suspense.html"},"React Suspense")," pour g\xe9rer les donn\xe9es en attente. Envelopper votre composant avec une limite ",Object(a.b)("inlineCode",{parentName:"p"},"Suspense")," interceptera tous les descendants qui sont toujours en attente et rendra une interface utilisateur de secours:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"function MonApplication() {\n  return (\n    <RecoilRoot>\n      <React.Suspense fallback={<div>Chargement...</div>}>\n        <CurrentUserInfo />\n      </React.Suspense>\n    </RecoilRoot>\n  );\n}\n")),Object(a.b)("h2",{id:"la-gestion-derreurs"},"La gestion d'erreurs"),Object(a.b)("p",null,"Mais que faire si la demande \xe0 \xe9chou\xe9e ou contient une erreur? Les s\xe9lecteurs Recoil peuvent \xe9galement g\xe9n\xe9rer des erreurs qui seront ensuite lanc\xe9es si un composant tente d'utiliser cette valeur. Cela peut \xeatre intercept\xe9 avec un React ","[",Object(a.b)("inlineCode",{parentName:"p"},"<ErrorBoundary>"),"]"," (",Object(a.b)("a",{parentName:"p",href:"https://reactjs.org/docs/error-boundaries.html"},"https://reactjs.org/docs/error-boundaries.html"),"). Par exemple:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const currentUserNameQuery = selector({\n  key: 'CurrentUserName',\n  get: async ({get}) => {\n    const response = await myDBQuery({\n      userID: get(currentUserIDState),\n    });\n    if (response.error) {\n      throw response.error;\n    }\n    return response.name;\n  },\n});\n\nfunction CurrentUserInfo() {\n  const userName = useRecoilValue(currentUserNameQuery);\n  return <div>{userName}</div>;\n}\n\nfunction MonApplication() {\n  return (\n    <RecoilRoot>\n      <ErrorBoundary>\n        <React.Suspense fallback={<div>Chargement...</div>}>\n          <CurrentUserInfo />\n        </React.Suspense>\n      </ErrorBoundary>\n    </RecoilRoot>\n  );\n}\n")),Object(a.b)("h2",{id:"requ\xeates-avec-param\xe8tres"},"Requ\xeates avec param\xe8tres"),Object(a.b)("p",null,'Parfois, vous souhaitez pouvoir interroger en fonction de param\xe8tres qui ne sont pas uniquement bas\xe9s sur un \xe9tat d\xe9riv\xe9. Par exemple, vous souhaiterez peut-\xeatre effectuer une requ\xeate en fonction des "props" du composant. Vous pouvez le faire en utilisant l\'assistant ',Object(a.b)("a",{parentName:"p",href:"/docs/api-reference/utils/selectorFamily"},Object(a.b)("strong",{parentName:"a"},Object(a.b)("inlineCode",{parentName:"strong"},"selectorFamily"))),":"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const userNameQuery = selectorFamily({\n  key: 'UserName',\n  get: userID => async () => {\n    const response = await myDBQuery({userID});\n    if (response.error) {\n      throw response.error;\n    }\n    return response.name;\n  },\n});\n\nfunction UserInfo({userID}) {\n  const userName = useRecoilValue(userNameQuery(userID));\n  return <div>{userName}</div>;\n}\n\nfunction MyApp() {\n  return (\n    <RecoilRoot>\n      <ErrorBoundary>\n        <React.Suspense fallback={<div>Loading...</div>}>\n          <UserInfo userID={1}/>\n          <UserInfo userID={2}/>\n          <UserInfo userID={3}/>\n        </React.Suspense>\n      </ErrorBoundary>\n    </RecoilRoot>\n  );\n}\n")),Object(a.b)("h2",{id:"graphe-de-flux-de-donn\xe9es"},"Graphe de flux de donn\xe9es"),Object(a.b)("p",null,"N'oubliez pas qu'en mod\xe9lisant les requ\xeates en tant que s\xe9lecteurs, nous pouvons cr\xe9er un graphe de flux de donn\xe9es m\xe9langeant l'\xe9tat, l'\xe9tat d\xe9riv\xe9 et les requ\xeates! Ce graphe se mettra \xe0 jour et re-rendra automatiquement les composants React \xe0 mesure que l'\xe9tat est chang\xe9."),Object(a.b)("p",null,"L'exemple suivant rendra le nom de l'utilisateur actuel et une liste de ses amis. Si vous cliquez sur le nom d'un ami, il deviendra l'utilisateur actuel et le nom et la liste seront automatiquement mis \xe0 jour."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const currentUserIDState = atom({\n  key: 'CurrentUserID',\n  default: null,\n});\n\nconst userInfoQuery = selectorFamily({\n  key: 'UserInfoQuery',\n  get: userID => async () => {\n    const response = await myDBQuery({userID});\n    if (response.error) {\n      throw response.error;\n    }\n    return response;\n  },\n});\n\nconst currentUserInfoQuery = selector({\n  key: 'CurrentUserInfoQuery',\n  get: ({get}) => get(userInfoQuery(get(currentUserIDState))),\n});\n\nconst friendsInfoQuery = selector({\n  key: 'FriendsInfoQuery',\n  get: ({get}) => {\n    const {friendList} = get(currentUserInfoQuery);\n    return friendList.map(friendID => get(userInfoQuery(friendID)));\n  },\n});\n\nfunction CurrentUserInfo() {\n  const currentUser = useRecoilValue(currentUserInfoQuery);\n  const friends = useRecoilValue(friendsInfoQuery);\n  const setCurrentUserID = useSetRecoilState(currentUserIDState);\n  return (\n    <div>\n      <h1>{currentUser.name}</h1>\n      <ul>\n        {friends.map(friend =>\n          <li key={friend.id} onClick={() => setCurrentUserID(friend.id)}>\n            {friend.name}\n          </li>\n        )}\n      </ul>\n    </div>\n  );\n}\n\nfunction MonApplication() {\n  return (\n    <RecoilRoot>\n      <ErrorBoundary>\n        <React.Suspense fallback={<div>Chargement...</div>}>\n          <CurrentUserInfo />\n        </React.Suspense>\n      </ErrorBoundary>\n    </RecoilRoot>\n  );\n}\n")),Object(a.b)("h2",{id:"requ\xeates-concomitantes"},"Requ\xeates concomitantes"),Object(a.b)("p",null,"Si vous remarquez dans l'exemple ci-dessus, ",Object(a.b)("inlineCode",{parentName:"p"},"friendsInfoQuery")," utilise une requ\xeate pour obtenir les informations de chaque ami. Mais, en faisant cela dans une boucle, ils sont essentiellement s\xe9rialis\xe9s. Si la recherche est rapide, c'est peut-\xeatre ok. Si le co\xfbt est cher, vous pouvez utiliser un assistant d'acc\xe8s concurrentiel tel que ",Object(a.b)("a",{parentName:"p",href:"/docs/api-reference/utils/waitForAll"},Object(a.b)("inlineCode",{parentName:"a"},"waitForAll"))," pour les ex\xe9cuter en parall\xe8le. Cet assistant accepte \xe0 la fois des tableaux et des objets nomm\xe9s de d\xe9pendances."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const friendsInfoQuery = selector({\n  key: 'FriendsInfoQuery',\n  get: ({get}) => {\n    const {friendList} = get(currentUserInfoQuery);\n    const friends = get(waitForAll(\n      friendList.map(friendID => userInfoQuery(friendID))\n    ));\n    return friends;\n  },\n});\n")),Object(a.b)("p",null,"Vous pouvez utiliser ",Object(a.b)("a",{parentName:"p",href:"/docs/api-reference/utils/waitForNone"},Object(a.b)("inlineCode",{parentName:"a"},"waitForNone"))," pour g\xe9rer les mises \xe0 jour incr\xe9mentielles de l'interface utilisateur avec des donn\xe9es partielles"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const friendsInfoQuery = selector({\n  key: 'FriendsInfoQuery',\n  get: ({get}) => {\n    const {friendList} = get(currentUserInfoQuery);\n    const friendLoadables = get(waitForNone(\n      friendList.map(friendID => userInfoQuery(friendID))\n    ));\n    return friendLoadables\n      .filter(({state}) => state === 'hasValue')\n      .map(({contents}) => contents);\n  },\n});\n")),Object(a.b)("h2",{id:"pr\xe9lecture"},"Pr\xe9lecture"),Object(a.b)("p",null,"Pour des raisons de performances, vous souhaitez peut-\xeatre lancer la r\xe9cup\xe9ration ",Object(a.b)("em",{parentName:"p"},"avant")," le rendu. De cette fa\xe7on, la requ\xeate peut continuer pendant que le rendu commence. La ",Object(a.b)("a",{parentName:"p",href:"https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early"},"Documentation de React")," donnent quelques exemples. Ce mod\xe8le fonctionne \xe9galement avec Recoil."),Object(a.b)("p",null,"Modifions l'exemple ci-dessus pour lancer une r\xe9cup\xe9ration des informations sur l'utilisateur suivant d\xe8s que l'utilisateur clique sur le bouton pour changer d'utilisateur:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"function CurrentUserInfo() {\n  const currentUser = useRecoilValue(currentUserInfoQuery);\n  const friends = useRecoilValue(friendsInfoQuery);\n\n  const changeUser = useRecoilCallback(({snapshot, set}) => userID => {\n    snapshot.getLoadable(userInfoQuery(userID)); // pr\xe9lit les informations utilisateur\n    set(currentUserIDState, userID); // change l'utilisateur courant pour commancer un nouveau rendu\n  });\n\n  return (\n    <div>\n      <h1>{currentUser.name}</h1>\n      <ul>\n        {friends.map(friend =>\n          <li key={friend.id} onClick={() => changeUser(friend.id)}>\n            {friend.name}\n          </li>\n        )}\n      </ul>\n    </div>\n  );\n}\n")),Object(a.b)("h2",{id:"requ\xeater-les-valeurs-par-d\xe9faut-de-atomes"},"Requ\xeater les valeurs par d\xe9faut de atomes"),Object(a.b)("p",null,"Un mod\xe8le courant consiste \xe0 utiliser un atome pour repr\xe9senter un \xe9tat modifiable local, mais \xe0 utiliser un s\xe9lecteur pour interroger les valeurs par d\xe9faut:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const currentUserIDState = atom({\n  key: 'CurrentUserID',\n  default: selector({\n    key: 'CurrentUserID/Default',\n    get: () => myFetchCurrentUserID(),\n  }),\n});\n")),Object(a.b)("p",null,"Si vous souhaitez une synchronisation bidirectionnelle des donn\xe9es, consid\xe9rez les ",Object(a.b)("a",{parentName:"p",href:"/docs/guides/atom-effects"},Object(a.b)("inlineCode",{parentName:"a"},"Effets Atomiques"))),Object(a.b)("h2",{id:"requ\xeates-asynchrones-sans-react-suspense"},"Requ\xeates asynchrones sans React Suspense"),Object(a.b)("p",null,"Il n'est pas n\xe9cessaire d'utiliser React Suspense pour g\xe9rer les s\xe9lecteurs asynchrones en attente. Vous pouvez \xe9galement utiliser le hook ",Object(a.b)("a",{parentName:"p",href:"/docs/api-reference/core/useRecoilValueLoadable"},Object(a.b)("inlineCode",{parentName:"a"},"useRecoilValueLoadable()"))," pour d\xe9terminer l'\xe9tat pendant le rendu:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"function UserInfo({userID}) {\n  const userNameLoadable = useRecoilValueLoadable(userNameQuery(userID));\n  switch (userNameLoadable.state) {\n    case 'hasValue':\n      return <div>{userNameLoadable.contents}</div>;\n    case 'loading':\n      return <div>Chargement...</div>;\n    case 'hasError':\n      throw userNameLoadable.contents;\n  }\n}\n")),Object(a.b)("h2",{id:"actualisation-de-requ\xeate"},"Actualisation de requ\xeate"),Object(a.b)("p",null,"Lorsque vous utilisez des s\xe9lecteurs pour mod\xe9liser des requ\xeates de donn\xe9es, il est important de se rappeler que l'\xe9valuation des s\xe9lecteurs doit toujours fournir un r\xe9sultat constante pour un \xe9tat donn\xe9. Les s\xe9lecteurs repr\xe9sentent l'\xe9tat d\xe9riv\xe9 d'autres \xe9tats d'atomes et de s\xe9lecteurs. Ainsi, les fonctions d'\xe9valuation des s\xe9lecteurs doivent \xeatre idempotentes pour une entr\xe9e donn\xe9e, car elles peuvent \xeatre mises en cache ou ex\xe9cut\xe9es plusieurs fois. En pratique, cela signifie qu'un seul s\xe9lecteur ne doit pas \xeatre utilis\xe9 pour une requ\xeate dont vous vous attendez \xe0 ce que les r\xe9sultats varient pendant la dur\xe9e de vie de l'application."),Object(a.b)("p",null,"Il existe quelques mod\xe8les que vous pouvez utiliser pour travailler avec des donn\xe9es mutables:"),Object(a.b)("h3",{id:"utiliser-des-requ\xeates-identifiable"},"Utiliser des requ\xeates identifiable"),Object(a.b)("p",null,"L'\xe9valuation du s\xe9lecteur doit fournir un r\xe9sultat constant pour un \xe9tat donn\xe9 en entr\xe9e (\xe9tat d\xe9pendant ou param\xe8tres de famille). Ainsi, vous pouvez ajouter un identifiant de demande en tant que param\xe8tre de famille ou en tant que d\xe9pendance \xe0 votre requ\xeate. Par exemple:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const userInfoQueryRequestIDState = atomFamily({\n  key: 'UserInfoQueryRequestID',\n  default: 0,\n});\n\nconst userInfoQuery = selectorFamily({\n  key: 'UserInfoQuery',\n  get: userID => async ({get}) => {\n    get(userInfoQueryRequestIDState(userID)); // Ajouter un identifiant de requ\xeate en tant que d\xe9pendence\n    const response = await myDBQuery({userID});\n    if (response.error) {\n      throw response.error;\n    }\n    return response;\n  },\n});\n\nfunction useRefreshUserInfo(userID) {\n  const setUserInfoQueryRequestID = useSetRecoilState(userInfoQueryRequestIDState(userID));\n  return () => {\n    setUserInfoQueryRequestID(requestID => requestID + 1);\n  };\n}\n\nfunction CurrentUserInfo() {\n  const currentUserID = useRecoilValue(currentUserIDState);\n  const currentUserInfo = useRecoilValue(userInfoQuery(currentUserID));\n  const refreshUserInfo = useRefreshUserInfo(currentUserID);\n\n  return (\n    <div>\n      <h1>{currentUser.name}</h1>\n      <button onClick={refreshUserInfo}>Rafra\xeechir</button>\n    </div>\n  );\n}\n")),Object(a.b)("h3",{id:"utiliser-un-atome"},"Utiliser un atome"),Object(a.b)("p",null,"Une autre option consiste \xe0 utiliser un atome, au lieu d'un s\xe9lecteur, pour mod\xe9liser les r\xe9sultats de la requ\xeate. Vous pouvez mettre \xe0 jour imp\xe9rativement  l'\xe9tat de l'atome avec les nouveaux r\xe9sultats de la requ\xeate en fonction de votre strat\xe9gie d'actualisation."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-jsx"},"const userInfoState = atomFamily({\n  key: 'UserInfo',\n  default: userID => fetch(userInfoURL(userID)),\n});\n\n// React component to refresh query\nfunction RefreshUserInfo({userID}) {\n  const refreshUserInfo = useRecoilCallback(({set}) => async id => {\n    const userInfo = await myDBQuery({userID});\n    set(userInfoState(userID), userInfo);\n  }, [userID]);\n\n  // Refresh user info every second\n  useEffect(() => {\n    const intervalID = setInterval(refreshUserInfo, 1000);\n    return () => clearInterval(intervalID);\n  }, [refreshUserInfo]);\n\n  return null;\n}\n")),Object(a.b)("p",null,"Un inconv\xe9nient de cette approche est que les atomes ne supportent pas ",Object(a.b)("em",{parentName:"p"},"pour l'instant")," l'acceptation d'une ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," comme nouvelle valeur afin de profiter automatiquement de React Suspense pendant que l'actualisation de la requ\xeate est en attente, si tel est le comportement souhait\xe9. Cependant, vous pouvez stocker un objet qui encode manuellement l'\xe9tat de chargement ainsi que les r\xe9sultats si vous le souhaitez."),Object(a.b)("p",null,"Tenez \xe9galement compte des ",Object(a.b)("a",{parentName:"p",href:"/docs/guides/atom-effects"},"Effets Atomiques")," pour la synchronisation des requ\xeates d'atomes."))}l.isMDXComponent=!0}}]);