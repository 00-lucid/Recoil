"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[7034],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return h}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(r),h=a,d=m["".concat(l,".").concat(h)]||m[h]||c[h]||o;return r?n.createElement(d,s(s({ref:t},p),{},{components:r})):n.createElement(d,s({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var u=2;u<o;u++)s[u]=r[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},4337:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return p},default:function(){return m}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),s=["components"],i={title:"GraphQL Selectors",sidebar_label:"GraphQL Selectors"},l=void 0,u={unversionedId:"recoil-relay/graphql-selectors",id:"recoil-relay/graphql-selectors",title:"GraphQL Selectors",description:"The underlying Relay GraphQL support is provided via the GraphQL Atom Effects.  For your convenience some selectors are provided to make most of the common usage patterns easier to use.  First, make sure to setup your Relay environment.",source:"@site/docs/recoil-relay/graphql-selectors.md",sourceDirName:"recoil-relay",slug:"/recoil-relay/graphql-selectors",permalink:"/docs/recoil-relay/graphql-selectors",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/docs/recoil-relay/graphql-selectors.md",tags:[],version:"current",frontMatter:{title:"GraphQL Selectors",sidebar_label:"GraphQL Selectors"},sidebar:"recoil-relay",previous:{title:"Relay Environment",permalink:"/docs/recoil-relay/environment"},next:{title:"Preloaded Queries",permalink:"/docs/recoil-relay/preloaded-queries"}},p=[{value:"Simple GraphQL Query",id:"simple-graphql-query",children:[],level:2},{value:"GraphQL Query with Parameters",id:"graphql-query-with-parameters",children:[],level:2},{value:"GraphQL Fragments",id:"graphql-fragments",children:[],level:2},{value:"GraphQL Mutations",id:"graphql-mutations",children:[],level:2},{value:"Write-through Cache",id:"write-through-cache",children:[],level:2},{value:"GraphQL Subscriptions",id:"graphql-subscriptions",children:[],level:2}],c={toc:p};function m(e){var t=e.components,r=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The underlying Relay GraphQL support is provided via the ",(0,o.kt)("a",{parentName:"p",href:"/docs/recoil-relay/graphql-effects"},"GraphQL Atom Effects"),".  For your convenience some selectors are provided to make most of the common usage patterns easier to use.  First, make sure to ",(0,o.kt)("a",{parentName:"p",href:"/docs/recoil-relay/environment"},"setup your Relay environment"),"."),(0,o.kt)("h2",{id:"simple-graphql-query"},"Simple GraphQL Query"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/recoil-relay/api/graphQLSelector"},(0,o.kt)("strong",{parentName:"a"},(0,o.kt)("inlineCode",{parentName:"strong"},"graphQLSelector()")))," can be used to create a selector which is synced with a ",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/"},(0,o.kt)("strong",{parentName:"a"},"GraphQL query")),".  This selector helps GraphQL queries and the Recoil data-flow graph stay in sync.  It can depend on upstream Recoil atoms/selectors to determine the ",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#variables"},(0,o.kt)("inlineCode",{parentName:"a"},"variables"))," to use for the GraphQL query or transform the results.  Any live queries, deferred data, local updates or mutations to the Relay GraphQL state will also automatically sync with the selector and cause it to update.  This allows you to treat the server as the source of truth with the selector as a local cache."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const userNameQuery = graphQLSelector({\n  key: 'UserName',\n  environment: myEnvironmentKey,\n  query: graphql`\n    query UserNameQuery($id: ID!) {\n      user(id: $id) {\n        name\n      }\n    }\n  `,\n  variables: ({get}) => ({id: get(currentIDAtom)}),\n  mapResponse: data => data.user?.name,\n});\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent() {\n  const seenCount = useRecoilValue(seenCountQuery);\n  return <span>{seenCount}</span>;\n}\n")),(0,o.kt)("p",null,"In addition to using other upstream atoms/selectors to compute the GraphQL query variables, the ",(0,o.kt)("inlineCode",{parentName:"p"},"graphQLSelector()")," can also be used by other downstream selectors to provide derived state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const pictureForUserState = selector({\n  key: 'PictureForUser',\n  get: async ({get}) => {\n    const username = get(userNameQuery);\n    const picture = await fetch(urlForUserNamePicture(username));\n    return picture;\n  },\n});\n")),(0,o.kt)("h2",{id:"graphql-query-with-parameters"},"GraphQL Query with Parameters"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/recoil-relay/api/graphQLSelectorFamily"},(0,o.kt)("strong",{parentName:"a"},(0,o.kt)("inlineCode",{parentName:"strong"},"graphQLSelectorFamily()")))," allows you to use parameters in addition to other Recoil state for computing query variables.  Parameters can be determined basd on a component's props, React state, used in another Recoil selector, etc."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const userQuery = graphQLSelectorFamily({\n  key: 'UserQuery',\n  environment: myEnvironmentKey,\n  query: graphql`\n    query UserQuery($id: ID!, $clientID: ClientID!) {\n      user(id: $id, client_id: $clientID) {\n        name\n        address\n      }\n    }\n  `,\n  variables: id => ({get}) => ({id, clientID: get(clientIDAtom}),\n  mapResponse: data => data.user,\n});\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent(props) {\n  const user = useRecoilValue(userQuery(props.userID));\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n    </div>\n  );\n}\n")),(0,o.kt)("p",null,"GraphQL queries can also be ",(0,o.kt)("a",{parentName:"p",href:"/docs/recoil-relay/preloaded-queries"},"preloaded"),"."),(0,o.kt)("h2",{id:"graphql-fragments"},"GraphQL Fragments"),(0,o.kt)("p",null,"GraphQL queries can also include ",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#fragments"},"GraphQL fragments")," through the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"readInlineData()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const userNameFragment = graphql`\n  fragment UserNameFragment on User @inline {\n    name\n  }\n`;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import {readInlineData} from 'relay-runtime';\n\nconst userNameQuery = graphQLSelectorFamily({\n  key: 'UserNameQuery',\n  environment: myEnvironmentKey,\n  query: graphql`\n    query UserNameQuery($id: ID!) {\n      user(id: $id) {\n        ...UserNameFragment\n      }\n    }\n  `,\n  variables: id => ({id}),\n  mapResponse: response => {\n    const userFragment = readInlineData(userNameFragment, response.user);\n    return userFragment?.name;\n  },\n})\n")),(0,o.kt)("h2",{id:"graphql-mutations"},"GraphQL Mutations"),(0,o.kt)("p",null,"The GraphQL selectors will perform an initial query as well as subscribe to any changes.  You can use Relay APIs such as ",(0,o.kt)("a",{parentName:"p",href:"https://relay.dev/docs/api-reference/use-mutation"},(0,o.kt)("strong",{parentName:"a"},(0,o.kt)("inlineCode",{parentName:"strong"},"useMutation()")))," and",(0,o.kt)("a",{parentName:"p",href:"https://relay.dev/docs/api-reference/commit-mutation"},(0,o.kt)("strong",{parentName:"a"},(0,o.kt)("inlineCode",{parentName:"strong"},"commitMutation()")))," to update the state on the server.  These changes will also sync and cause the Recoil GraphQL selectors to update.  This allows you to treat the server as the source of truth with the selector as a local cache."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent(props) {\n  const user = useRecoilValue(userQuery(props.userID));\n  const [commitEvent] = useMutation(graphql`\n    mutation UserMutation($input: UsertNameChangeData!) {\n      user_mutation(data: $input) {\n        user {\n          id\n          name\n        }\n      }\n    }\n  `);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => {\n        commitEvent({\n          variables: {\n            input: {\n              id: props.userID,\n              name: 'New Name',\n            },\n          },\n        });\n      }}>Change Name</button>\n    </div>\n  );\n}\n")),(0,o.kt)("h2",{id:"write-through-cache"},"Write-through Cache"),(0,o.kt)("p",null,"Another pattern you can use for updating state is to treat the Recoil selector as a local write-through cache for the server.  It is a writable selector, so local updates will immediately be reflected in the UI.  If you provide ",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#mutations"},(0,o.kt)("strong",{parentName:"a"},"GraphQL mutation"))," information, then updating the selector will also initiate a mutation with the server."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const userState = graphQLSelector({\n  key: 'User',\n  environment: relayFBEnvironmentKey,\n  query: graphql`\n    query UserQuery($eventID: ID!, $clientID: ClientID!) {\n      user(id: $eventID, client_id: $clientID) {\n        name\n        timestamp\n      }\n    }\n  `,\n  variables: id => ({get}) => ({id, clientID: get(clientIDAtom}),\n  mapResponse: data => data.user,\n\n  mutations: {\n    mutation: graphql`\n      mutation UserMutation($input: UserNameChangeData!) {\n        user_mutation(data: $input) {\n          user {\n            id\n            name\n          }\n        }\n      }\n    `,\n    variables: newUserData => id => ({input: {id, name: newUserData.name}}),\n  },\n});\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent() {\n  const [user, setUser] = useRecoilState(userState);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => {\n        setUser(user => ({...user, name: 'New Name'}));\n      }}>Change Name</button>\n    </div>\n  );\n}\n")),(0,o.kt)("p",null,'Note that when using Recoil as a write-through cache like this the Relay concept of "optimistic response" is not necessary for mutations since updating the selector will update the UI before the remote mutation is committed.  If there is an error from the server then the local update will be rolled back.'),(0,o.kt)("h2",{id:"graphql-subscriptions"},"GraphQL Subscriptions"),(0,o.kt)("p",null,"While GraphQL selectors will subscribe to changes from locally issued mutations or live updates, you may also want to subscribe to updates pushed by the server.  In this situation you can use a ",(0,o.kt)("strong",{parentName:"p"},"GraphQL ",(0,o.kt)("em",{parentName:"strong"},"subscription"))," instead of a GraphQL ",(0,o.kt)("em",{parentName:"p"},"query"),".  GraphQL subscriptions require a different implementation on the server to support initiating remote updates."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const userSubscription = graphQLSelector({\n  key: 'UserSubscription',\n  environment: myEnvironmentKey,\n  query: graphql`\n    subscription UserSubscription($id: ID!) {\n      user(id: $id) {\n        name\n        address\n      }\n    }\n  `,\n  variables: ({get}) => ({id: get(currentIDAtom)}),\n  mapResponse: data => data.user,\n});\n")))}m.isMDXComponent=!0}}]);