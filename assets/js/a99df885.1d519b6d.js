"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[2094],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return u}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(a),u=o,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||i;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function u(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,s=new Array(i);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4922:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var n=a(7462),o=a(3366),i=(a(7294),a(3905)),s=["components"],r={title:"class Snapshot",sidebar_label:"Snapshot"},l=void 0,c={unversionedId:"api-reference/core/Snapshot",id:"api-reference/core/Snapshot",title:"class Snapshot",description:"A Snapshot object represents an immutable snapshot of the state of Recoil atoms.  It is intended to standardize the API for observing, inspecting, and managing global Recoil state.  It is mostly useful for dev tools, global state synchronization, history navigation, etc.",source:"@site/docs/api-reference/core/Snapshot.md",sourceDirName:"api-reference/core",slug:"/api-reference/core/Snapshot",permalink:"/docs/api-reference/core/Snapshot",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/docs/api-reference/core/Snapshot.md",tags:[],version:"current",frontMatter:{title:"class Snapshot",sidebar_label:"Snapshot"},sidebar:"docs",previous:{title:"useRecoilCallback()",permalink:"/docs/api-reference/core/useRecoilCallback"},next:{title:"useRecoilTransactionObserver()",permalink:"/docs/api-reference/core/useRecoilTransactionObserver"}},p=[{value:"Obtaining Snapshots",id:"obtaining-snapshots",children:[{value:"Hooks",id:"hooks",children:[],level:3},{value:"Creating a fresh Snapshot",id:"creating-a-fresh-snapshot",children:[],level:3}],level:2},{value:"Reading Snapshots",id:"reading-snapshots",children:[{value:"Example",id:"example",children:[],level:3}],level:2},{value:"Transforming Snapshots",id:"transforming-snapshots",children:[],level:2},{value:"Going to a Snapshot",id:"going-to-a-snapshot",children:[],level:2},{value:"Asynchronous use of Snapshots",id:"asynchronous-use-of-snapshots",children:[],level:2},{value:"Developer Tools",id:"developer-tools",children:[{value:"Snapshot IDs",id:"snapshot-ids",children:[],level:3},{value:"Enumerate Atoms and Selectors",id:"enumerate-atoms-and-selectors",children:[],level:3},{value:"Debug information",id:"debug-information",children:[],level:3}],level:2},{value:"State Initialization",id:"state-initialization",children:[],level:2}],h={toc:p};function d(e){var t=e.components,a=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot")," object represents an immutable snapshot of the state of Recoil ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/atom"},"atoms"),".  It is intended to standardize the API for observing, inspecting, and managing global Recoil state.  It is mostly useful for dev tools, global state synchronization, history navigation, etc."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"class Snapshot {\n  retain(): () => void;\n  isRetained(): boolean;\n\n  // Accessors to inspect snapshot state\n  getLoadable: <T>(RecoilValue<T>) => Loadable<T>;\n  getPromise: <T>(RecoilValue<T>) => Promise<T>;\n\n  // API to transform snapshots for transactions\n  map: (MutableSnapshot => void) => Snapshot;\n  asyncMap: (MutableSnapshot => Promise<void>) => Promise<Snapshot>;\n\n  // Developer Tools API\n  getID: () => SnapshotID;\n  getNodes_UNSTABLE: ({\n    isModified?: boolean,\n  } | void) => Iterable<RecoilValue<mixed>>;\n  getInfo_UNSTABLE: <T>(RecoilValue<T>) => {...};\n}\n\nfunction snapshot_UNSTABLE(initializeState?: (MutableSnapshot => void)): Snapshot\n")),(0,i.kt)("h2",{id:"obtaining-snapshots"},"Obtaining Snapshots"),(0,i.kt)("h3",{id:"hooks"},"Hooks"),(0,i.kt)("p",null,"Recoil provides the following hooks for obtaining snapshots based on the current state:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useRecoilCallback"},(0,i.kt)("inlineCode",{parentName:"a"},"useRecoilCallback()"))," - Asynchronous access to a Snapshot."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useRecoilSnapshot"},(0,i.kt)("inlineCode",{parentName:"a"},"useRecoilSnapshot()"))," - Synchronous access to a Snapshot.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Using this hook will subscribe your component to re-render for ",(0,i.kt)("em",{parentName:"li"},"all")," Recoil state changes."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useRecoilTransactionObserver"},(0,i.kt)("inlineCode",{parentName:"a"},"useRecoilTransactionObserver_UNSTABLE()"))," - Subscribe to Snapshots for all state changes.")),(0,i.kt)("h3",{id:"creating-a-fresh-snapshot"},"Creating a fresh Snapshot"),(0,i.kt)("p",null,"You can also build a fresh snapshot using the ",(0,i.kt)("inlineCode",{parentName:"p"},"snapshot_UNSTABLE()")," factory.  This can be used for ",(0,i.kt)("a",{parentName:"p",href:"/docs/guides/testing"},"testing")," or evaluating selectors outside of a React context.  All atoms in the snapshot will start in their default state, however atom effects will still be run and can initialize atoms to dynamic values.  ",(0,i.kt)("inlineCode",{parentName:"p"},"snapshot_UNSTABLE()")," also accepts an optional callback to initialize state, though atom effect initializations takes precedence.  Also note that selector caches are shared across Recoil roots and snapshots, though they can be cleared using ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/selector#returning-objects-with-callbacks"},"callbacks"),"."),(0,i.kt)("h2",{id:"reading-snapshots"},"Reading Snapshots"),(0,i.kt)("p",null,"Snapshots are read-only with respect to atom state.  They can be used to read atom state and evaluate selectors' derived state.  ",(0,i.kt)("inlineCode",{parentName:"p"},"getLoadable()")," provides a ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/Loadable"},(0,i.kt)("inlineCode",{parentName:"a"},"Loadable"))," with the state of the atom or selector in this Snapshot.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"getPromise()")," method can be used to wait for the evaluated value of asynchronous selectors, so you can see what the value would be based on the static atom state."),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'function MyComponent() {\n  const logState = useRecoilCallback(({snapshot}) => () => {\n    console.log("State: ", snapshot.getLoadable(myAtom).contents);\n\n    const newSnapshot = snapshot.map(({set}) => set(myAtom, 42));\n  });\n}\n')),(0,i.kt)("h2",{id:"transforming-snapshots"},"Transforming Snapshots"),(0,i.kt)("p",null,"There are cases where you may wish to mutate a snapshot.  While snapshots are immutable, they have methods to map themselves with a set of transformations to a new immutable snapshot.  The map methods take a callback that is passed a MutableSnapshot, which is mutated throughout the callback and will ultimately become the new snapshot returned by the mapping operation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"class MutableSnapshot {\n  set: <T>(RecoilState<T>, T | DefaultValue | (T => T | DefaultValue)) => void;\n  reset: <T>(RecoilState<T>) => void;\n}\n")),(0,i.kt)("p",null,"Notice that ",(0,i.kt)("inlineCode",{parentName:"p"},"set()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()")," have the same signature as callbacks provided to a writeable selector's ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," property, but they only effect the new snapshot, not the current state."),(0,i.kt)("h2",{id:"going-to-a-snapshot"},"Going to a Snapshot"),(0,i.kt)("p",null,"The following hook can be used for updating the current Recoil state to match the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useGotoRecoilSnapshot"},(0,i.kt)("inlineCode",{parentName:"a"},"useGotoRecoilSnapshot()"))," - Update current state to match a Snapshot")),(0,i.kt)("h2",{id:"asynchronous-use-of-snapshots"},"Asynchronous use of Snapshots"),(0,i.kt)("p",null,"Snapshots are only retained for the duration of the callback that obtained them.  To use them after that they should be explicitly retained using ",(0,i.kt)("inlineCode",{parentName:"p"},"retain()"),"."),(0,i.kt)("p",null,"From a callback:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"useRecoilCallback(({snapshot}) => async () => {\n  const release = snapshot.retain();\n  try {\n    await onSomething();\n    doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n});\n")),(0,i.kt)("p",null,"Note that an asynchronous selector must be actively used by some ",(0,i.kt)("inlineCode",{parentName:"p"},"<RecoilRoot>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot")," in order to ensure it is not canceled.  So, if you are only accessing an asynchronous selector via snapshots, they must be retained in order to guarantee you can observe the resolved value."),(0,i.kt)("h2",{id:"developer-tools"},"Developer Tools"),(0,i.kt)("p",null,"Snapshots provide some methods useful for ",(0,i.kt)("a",{parentName:"p",href:"/docs/guides/dev-tools"},"building developer tools")," or debugging capabilities with Recoil.  This API is still evolving, and thus marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"_UNSTABLE"),", as we work on the initial dev tools."),(0,i.kt)("h3",{id:"snapshot-ids"},"Snapshot IDs"),(0,i.kt)("p",null,"Each committed state or mutated Snapshot has a unique opaque version ID that can be obtained via ",(0,i.kt)("inlineCode",{parentName:"p"},"getID()"),". This can be used to detect when we have gone back to a previous snapshot via ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useGotoRecoilSnapshot"},(0,i.kt)("inlineCode",{parentName:"a"},"useGotoRecoilSnapshot()")),"."),(0,i.kt)("h3",{id:"enumerate-atoms-and-selectors"},"Enumerate Atoms and Selectors"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"getNodes_UNSTABLE()")," method can be used to iterate all atoms and selectors that were in use for this snapshot.  Atoms, selectors, and families may be created at any time.  However, they will only show up in the snapshot if they are actually used.  Atoms and selectors may be removed from subsequent state snapshots if they are no longer being used."),(0,i.kt)("p",null,"An optional ",(0,i.kt)("inlineCode",{parentName:"p"},"isModified")," flag may be specified to only return atoms which have been modified since the last transaction."),(0,i.kt)("h3",{id:"debug-information"},"Debug information"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"getInfo_UNSTABLE()")," method provides additional debug information for atoms and selectors.  The debug information provided is evolving, but may include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"loadable")," - A Loadable with the current state.  Unlike methods like ",(0,i.kt)("inlineCode",{parentName:"li"},"getLoadable()"),", this method will not mutate the snapshot at all.  It provides the current state and will not initialize new atoms/selectors, perform any new selector evaluations, or update any dependencies or subscriptions."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isSet")," - True if this is an atom with an explicit value stored in the snapshot state.  False if this is a selector or using the default atom state."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isModified")," - True if this is an atom which was modified since the last transaction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"type")," - Either an ",(0,i.kt)("inlineCode",{parentName:"li"},"atom")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"selector")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deps")," - An iterator over the atoms or selectors this node depends on."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"subscribers")," - Information about what is subscribing to this node for this snapshot.  Details under development.")),(0,i.kt)("p",null,"This is similar to the ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useGetRecoilValueInfo"},(0,i.kt)("inlineCode",{parentName:"a"},"useGetRecoilValueInfo_UNSTABLE()"))," hook, but provides information based on the state in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot")," instead of the current state.  It cannot provide information not associated with a snapshot of Recoil state, such as subscribing React components."),(0,i.kt)("h2",{id:"state-initialization"},"State Initialization"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/RecoilRoot"},(0,i.kt)("inlineCode",{parentName:"a"},"<RecoilRoot>"))," component and ",(0,i.kt)("inlineCode",{parentName:"p"},"snapshot_UNSTABLE()")," factory take an optional ",(0,i.kt)("inlineCode",{parentName:"p"},"initializeState")," prop for initializing the state via a ",(0,i.kt)("inlineCode",{parentName:"p"},"MutableSnapshot"),".  This can be helpful for loading persisted state when you know all atoms in advance and is compatible with server-side rendering where the state should be setup synchronously with the initial render.  For per-atom initialization/persistence and ease of working with dynamic atoms, consider ",(0,i.kt)("a",{parentName:"p",href:"/docs/guides/atom-effects"},"atom effects"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyApp() {\n  function initializeState({set}) {\n    set(myAtom, 'foo');\n  }\n\n  return (\n    <RecoilRoot initializeState={initializeState}>\n      ...\n    </RecoilRoot>\n  );\n}\n")))}d.isMDXComponent=!0}}]);