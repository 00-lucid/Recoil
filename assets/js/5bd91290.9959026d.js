(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[3182],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(i,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var c=2;c<o;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2050:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return s},toc:function(){return i},default:function(){return u}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),l={title:"selector(options)",sidebar_label:"selector()"},s={unversionedId:"api-reference/core/selector",id:"api-reference/core/selector",isDocsHomePage:!1,title:"selector(options)",description:'Selectors represent a function, or derived state in Recoil.  You can think of them as similar to an "idempotent" or "pure function" without side-effects that always returns the same value for a given set of dependency values.  If only a get function is provided, the selector is read-only and returns a RecoilValueReadOnly object.  If a set is also provided, it returns a writeable RecoilState object.',source:"@site/docs/api-reference/core/selector.md",sourceDirName:"api-reference/core",slug:"/api-reference/core/selector",permalink:"/docs/api-reference/core/selector",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/docs/api-reference/core/selector.md",version:"current",sidebar_label:"selector()",frontMatter:{title:"selector(options)",sidebar_label:"selector()"},sidebar:"docs",previous:{title:"atom(options)",permalink:"/docs/api-reference/core/atom"},next:{title:"class Loadable",permalink:"/docs/api-reference/core/Loadable"}},i=[{value:"Dynamic Dependencies",id:"dynamic-dependencies",children:[]},{value:"Writeable Selectors",id:"writeable-selectors",children:[]},{value:"Asynchronous Selectors",id:"asynchronous-selectors",children:[]},{value:"Example (Synchronous)",id:"example-synchronous",children:[]},{value:"Example (Asynchronous)",id:"example-asynchronous",children:[]},{value:"Returning objects with callbacks",id:"returning-objects-with-callbacks",children:[]}],c={toc:i};function u(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Selectors")," represent a function, or ",(0,o.kt)("strong",{parentName:"p"},"derived state"),' in Recoil.  You can think of them as similar to an "idempotent" or "pure function" without side-effects that always returns the same value for a given set of dependency values.  If only a ',(0,o.kt)("inlineCode",{parentName:"p"},"get")," function is provided, the selector is read-only and returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"RecoilValueReadOnly")," object.  If a ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," is also provided, it returns a writeable ",(0,o.kt)("inlineCode",{parentName:"p"},"RecoilState")," object."),(0,o.kt)("p",null,"Recoil manages atom and selector state changes to know when to notify components subscribing to that selector to re-render.  If an object value of a selector is mutated directly it may bypass this and avoid properly notifying subscribing components.  To help detect bugs, Recoil will freeze selector value objects in development mode."),(0,o.kt)("hr",null),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function selector<T>({\n  key: string,\n\n  get: ({\n    get: GetRecoilValue,\n    getCallback: GetCallback,\n  }) => T | Promise<T> | RecoilValue<T>,\n\n  set?: (\n    {\n      get: GetRecoilValue,\n      set: SetRecoilState,\n      reset: ResetRecoilState,\n    },\n    newValue: T | DefaultValue,\n  ) => void,\n\n  dangerouslyAllowMutability?: boolean,\n})\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"type ValueOrUpdater<T> = T | DefaultValue | ((prevValue: T) => T | DefaultValue);\ntype GetCallback =\n  <Args, Return>(\n    fn: ({snapshot: Snapshot}) => (...Args) => Return,\n  ) => (...Args) => Return;\n\ntype GetRecoilValue = <T>(RecoilValue<T>) => T;\ntype SetRecoilState = <T>(RecoilState<T>, ValueOrUpdater<T>) => void;\ntype ResetRecoilState = <T>(RecoilState<T>) => void;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"key")," - A unique string used to identify the selector internally. This string should be unique with respect to other atoms and selectors in the entire application.  It needs to be stable across executions if used for persistence."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"get")," - A function that evaluates the value for the derived state.  It may return either a value directly or an asynchronous ",(0,o.kt)("inlineCode",{parentName:"li"},"Promise")," or another atom or selector representing the same type.  It is passed an object as the first parameter containing the following properties:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"get()")," - a function used to retrieve values from other atoms/selectors. All atoms/selectors passed to this function will be implicitly added to a list of ",(0,o.kt)("strong",{parentName:"li"},"dependencies")," for the selector. If any of the selector's dependencies change, the selector will re-evaluate."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"getCallback()")," - a function for creating Recoil-aware callbacks.  See ",(0,o.kt)("a",{parentName:"li",href:"/docs/api-reference/core/selector#returning-objects-with-callbacks"},"example")," below."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"set?")," - If this property is set, the selector will return ",(0,o.kt)("strong",{parentName:"li"},"writeable")," state. A function that is passed an object of callbacks as the first parameter and the new incoming value.  The incoming value may be a value of type ",(0,o.kt)("inlineCode",{parentName:"li"},"T")," or maybe an object of type ",(0,o.kt)("inlineCode",{parentName:"li"},"DefaultValue")," if the user reset the selector.  The callbacks include:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"get()")," - a function used to retrieve values from other atoms/selectors. This function will not subscribe the selector to the given atoms/selectors."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"set()")," - a function used to set the values of upstream Recoil state. The first parameter is the Recoil state and the second parameter is the new value.  The new value may be an updater function or a ",(0,o.kt)("inlineCode",{parentName:"li"},"DefaultValue")," object to propagate reset actions."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"reset()")," - a function used to reset to the default values of upstream Recoil state. The only parameter is the Recoil state."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"dangerouslyAllowMutability")," - In some cases it may be desireable allow mutating of objects stored in selectors that don't represent state changes.  Use this option to override freezing objects in development mode.")),(0,o.kt)("hr",null),(0,o.kt)("p",null,"A selector with a simple static dependency:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const mySelector = selector({\n  key: 'MySelector',\n  get: ({get}) => get(myAtom) * 100,\n});\n")),(0,o.kt)("h3",{id:"dynamic-dependencies"},"Dynamic Dependencies"),(0,o.kt)("p",null,"A read-only selector has a ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," method which evaluates the value of the selector based on dependencies.  If any of those dependencies are updated, then the selector will re-evaluate.  The dependencies are dynamically determined based on the atoms or selectors you actually use when evaluating the selector.  Depending on the values of the previous dependencies, you may dynamically use different additional dependencies.  Recoil will automatically update the current data-flow graph so that the selector is only subscribed to updates from the current set of dependencies"),(0,o.kt)("p",null,"In this example ",(0,o.kt)("inlineCode",{parentName:"p"},"mySelector")," will depend on the ",(0,o.kt)("inlineCode",{parentName:"p"},"toggleState")," atom as well as either ",(0,o.kt)("inlineCode",{parentName:"p"},"selectorA")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"selectorB")," depending on the state of ",(0,o.kt)("inlineCode",{parentName:"p"},"toggleState"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const toggleState = atom({key: 'Toggle', default: false});\n\nconst mySelector = selector({\n  key: 'MySelector',\n  get: ({get}) => {\n    const toggle = get(toggleState);\n    if (toggle) {\n      return get(selectorA);\n    } else {\n      return get(selectorB);\n    }\n  },\n});\n")),(0,o.kt)("h3",{id:"writeable-selectors"},"Writeable Selectors"),(0,o.kt)("p",null,"A bi-directional selector receives the incoming value as a parameter and can use that to propagate the changes back upstream along the data-flow graph.  Because the user may either set the selector with a new value or reset the selector, the incoming value is either of the same type that the selector represents or a ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultValue")," object which represents a reset action."),(0,o.kt)("p",null,"This simple selector essentially wraps an atom to add an additional field.  It just passes through set and reset operations to the upstream atom."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const proxySelector = selector({\n  key: 'ProxySelector',\n  get: ({get}) => ({...get(myAtom), extraField: 'hi'}),\n  set: ({set}, newValue) => set(myAtom, newValue),\n});\n")),(0,o.kt)("p",null,"This selector transforms the data, so needs to check if the incoming value is a ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultValue"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const transformSelector = selector({\n  key: 'TransformSelector',\n  get: ({get}) => get(myAtom) * 100,\n  set: ({set}, newValue) =>\n    set(myAtom, newValue instanceof DefaultValue ? newValue : newValue / 100),\n});\n")),(0,o.kt)("h3",{id:"asynchronous-selectors"},"Asynchronous Selectors"),(0,o.kt)("p",null,"Selectors may also have asynchronous evaluation functions and return a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," to the output value.  Please see ",(0,o.kt)("a",{parentName:"p",href:"/docs/guides/asynchronous-data-queries"},"this guide")," for more information."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const myQuery = selector({\n  key: 'MyQuery',\n  get: async ({get}) => {\n    return await myAsyncQuery(get(queryParamState));\n  }\n});\n")),(0,o.kt)("h3",{id:"example-synchronous"},"Example (Synchronous)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import {atom, selector, useRecoilState, DefaultValue} from 'recoil';\n\nconst tempFahrenheit = atom({\n  key: 'tempFahrenheit',\n  default: 32,\n});\n\nconst tempCelsius = selector({\n  key: 'tempCelsius',\n  get: ({get}) => ((get(tempFahrenheit) - 32) * 5) / 9,\n  set: ({set}, newValue) =>\n    set(\n      tempFahrenheit,\n      newValue instanceof DefaultValue ? newValue : (newValue * 9) / 5 + 32\n    ),\n});\n\nfunction TempCelsius() {\n  const [tempF, setTempF] = useRecoilState(tempFahrenheit);\n  const [tempC, setTempC] = useRecoilState(tempCelsius);\n  const resetTemp = useResetRecoilState(tempCelsius);\n\n  const addTenCelsius = () => setTempC(tempC + 10);\n  const addTenFahrenheit = () => setTempF(tempF + 10);\n  const reset = () => resetTemp();\n\n  return (\n    <div>\n      Temp (Celsius): {tempC}\n      <br />\n      Temp (Fahrenheit): {tempF}\n      <br />\n      <button onClick={addTenCelsius}>Add 10 Celsius</button>\n      <br />\n      <button onClick={addTenFahrenheit}>Add 10 Fahrenheit</button>\n      <br />\n      <button onClick={reset}>>Reset</button>\n    </div>\n  );\n}\n")),(0,o.kt)("h3",{id:"example-asynchronous"},"Example (Asynchronous)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import {selector, useRecoilValue} from 'recoil';\n\nconst myQuery = selector({\n  key: 'MyDBQuery',\n  get: async () => {\n    const response = await fetch(getMyRequestUrl());\n    return response.json();\n  },\n});\n\nfunction QueryResults() {\n  const queryResults = useRecoilValue(myQuery);\n\n  return (\n    <div>\n      {queryResults.foo}\n    </div>\n  );\n}\n\nfunction ResultsSection() {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <QueryResults />\n    </React.Suspense>\n  );\n}\n")),(0,o.kt)("p",null,"Please see ",(0,o.kt)("a",{parentName:"p",href:"/docs/guides/asynchronous-data-queries"},"this guide")," for more complex examples."),(0,o.kt)("h3",{id:"returning-objects-with-callbacks"},"Returning objects with callbacks"),(0,o.kt)("p",null,"Sometimes selectors can be used to return objects that contain callbacks.  It may be helpful for these callbacks to access Recoil state, such as for querying typeahead values or click handlers.  The following example uses a selector to generate menu items with a click handler that accesses Recoil state.  This can be useful when passing these objects to frameworks or logic outside the context of a React component."),(0,o.kt)("p",null,"There is symmetry between this callback and using ",(0,o.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useRecoilCallback"},(0,o.kt)("inlineCode",{parentName:"a"},"useRecoilCallback()")),".  Note that the callback returned by ",(0,o.kt)("inlineCode",{parentName:"p"},"getCallback()")," can be used as an async callback to access Recoil state later, it should not be called during the evaluation of the selector value itself."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const menuItemState = selectorFamily({\n  key: 'MenuItem',\n  get: itemID => ({get, getCallback}) => {\n    const name = get(itemNameQuery(itemID));\n    const onClick = getCallback(({snapshot}) => async () => {\n      const info = await snapshot.getPromise(itemInfoQuery(itemID));\n      displayInfoModal(info);\n    });\n    return {\n      title: `Show info for ${name}`,\n      onClick,\n    };\n  },\n});\n")))}u.isMDXComponent=!0}}]);